{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"x402_mock","text":"<p>A production-grade Python module implementing the HTTP 402 Payment Required workflow.</p>"},{"location":"#overview","title":"Overview","text":"<p><code>x402_mock</code> seamlessly integrates Web2 HTTP protocol with Web3 on-chain payments, enabling automated payment workflows based on the HTTP 402 status code.</p> <p>Core Tech Stack: - Web3 + ERC20 (USDC optimized) - USDC: ERC-3009 offline authorization (<code>transferWithAuthorization</code>) - Generic ERC20: Permit2 offline authorization (<code>permitTransferFrom</code>) - Asynchronous on-chain settlement</p> <p>Payment Flow: <pre><code>Client (Requester) \u2192 Server (Recipient) \u2192 On-chain Settlement\n</code></pre></p>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li>\u2705 Standardized payment protocol based on HTTP 402</li> <li>\u2705 USDC gas optimization via ERC-3009 (single-step authorization + transfer)</li> <li>\u2705 Broad ERC20 coverage via Permit2 offline signing</li> <li>\u2705 Asynchronous on-chain settlement without blocking business flow</li> <li>\u2705 Multiple payment method negotiation and matching</li> <li>\ud83e\udd16 Designed for Agent-to-Agent automated payment scenarios</li> </ul>"},{"location":"#installation","title":"Installation","text":"<p>This project uses <code>uv</code> as the package management tool.</p> <pre><code>uv add x402-mock\nuv sync\n</code></pre>"},{"location":"#environment-configuration","title":"Environment Configuration","text":"<p>Create a <code>.env</code> file in the project root:</p> <pre><code>EVM_PRIVATE_KEY=your_private_key_here\nEVM_INFURA_KEY=your_infura_key_here  # Optional\n</code></pre> <p>Required: - <code>EVM_PRIVATE_KEY</code> - Wallet private key for signing and on-chain transactions</p> <p>Optional: - <code>EVM_INFURA_KEY</code> - RPC/Infra provider key (uses public nodes if not provided)</p>"},{"location":"#quick-start","title":"Quick Start","text":""},{"location":"#server-example","title":"Server Example","text":"<pre><code>from x402_mock.servers import Http402Server, create_private_key\n\ntoken_key = create_private_key()\napp = Http402Server(token_key=token_key, token_expires_in=300)\n\napp.add_payment_method(\n    chain_id=\"eip155:11155111\",\n    amount=0.5,\n    currency=\"USDC\",\n)\n\n@app.get(\"/api/protected-data\")\n@app.payment_required\nasync def get_protected_data(authorization):\n    return {\"message\": \"Payment verified successfully\"}\n</code></pre>"},{"location":"#client-example","title":"Client Example","text":"<pre><code>from x402_mock.clients.http_client import Http402Client\n\nasync with Http402Client() as client:\n    client.add_payment_method(\n        chain_id=\"eip155:11155111\",\n        amount=0.8,\n        currency=\"USDC\"\n    )\n    response = client.get(\"http://localhost:8000/api/protected-data\")\n</code></pre>"},{"location":"#next-steps","title":"Next Steps","text":"<ul> <li>Check the API Reference for detailed documentation</li> <li>See the GitHub repository for more examples: https://github.com/OpenPayhub/x402-mock</li> <li>\u26a0\ufe0f Test on testnet (e.g., Sepolia) before production use</li> </ul>"},{"location":"reference/","title":"API Reference","text":"<p>Comprehensive API documentation for x402_mock module.</p>"},{"location":"reference/#servers","title":"Servers","text":"<p>HTTP 402 Payment Protocol Server Implementation</p> <p>The Servers module provides a FastAPI-based server framework for implementing HTTP 402 Payment Required protocol. It offers an event-driven architecture that encapsulates all payment collection logic, allowing payment receivers to integrate cryptocurrency payment acceptance with minimal configuration.</p> <p>Key Features: - FastAPI Integration: Extended FastAPI application with built-in payment endpoint routes - Token Management: Secure HMAC-signed access token generation and verification - Event-Driven Architecture: Subscribe to payment lifecycle events (request, verification, settlement) - Multi-Chain Support: Register multiple payment methods across different blockchain networks - Auto-Settlement: Optional automatic on-chain settlement after successful verification - Security Utilities: Private key generation, token signing, and environment key management - Modern EVM Signing:   - USDC: ERC-3009 (<code>transferWithAuthorization</code>)   - Generic ERC20: Permit2 (<code>permitTransferFrom</code>)</p> <p>Main Components: - <code>Http402Server</code>: Main server class extending FastAPI with payment protocol support - Security helpers: <code>generate_token()</code>, <code>verify_token()</code>, <code>create_private_key()</code>, <code>save_key_to_env()</code></p>"},{"location":"reference/#x402_mock.servers","title":"<code>x402_mock.servers</code>","text":""},{"location":"reference/#x402_mock.servers.Http402Server","title":"<code>Http402Server</code>","text":"<p>               Bases: <code>FastAPI</code></p> <p>FastAPI server with X402 payment protocol support.</p>"},{"location":"reference/#x402_mock.servers.Http402Server.__init__","title":"<code>__init__(token_key: str, adapter_hub: Optional[AdapterHub] = None, token_expires_in: int = 3600, enable_auto_settlement: bool = True, token_endpoint: str = '/token', **fastapi_kwargs)</code>","text":"<p>Initialize X402 payment server.</p> <p>Parameters:</p> Name Type Description Default <code>token_key</code> <code>str</code> <p>Secret key for signing access tokens</p> required <code>adapter_hub</code> <code>Optional[AdapterHub]</code> <p>Payment adapter hub (default: new instance)</p> <code>None</code> <code>token_expires_in</code> <code>int</code> <p>Token lifetime in seconds (default: 3600)</p> <code>3600</code> <code>enable_auto_settlement</code> <code>bool</code> <p>Auto-settle after verification (default: True)</p> <code>True</code> <code>token_endpoint</code> <code>str</code> <p>Token endpoint path (default: /token)</p> <code>'/token'</code> <code>**fastapi_kwargs</code> <p>FastAPI arguments (title, version, etc.)</p> <code>{}</code>"},{"location":"reference/#x402_mock.servers.Http402Server.add_payment_method","title":"<code>add_payment_method(payment_component: Union[PaymentComponentTypes, Dict[str, Any]]) -&gt; None</code>","text":"<p>Register a payment method.</p> <p>Parameters:</p> Name Type Description Default <code>payment_component</code> <code>Union[PaymentComponentTypes, Dict[str, Any]]</code> <p>A <code>PaymentComponentTypes</code> instance or a plain dict                that will be coerced into the correct type.</p> required"},{"location":"reference/#x402_mock.servers.Http402Server.subscribe","title":"<code>subscribe(event_class: type[BaseEvent], handler: Callable) -&gt; None</code>","text":"<p>Register event handler.</p> <p>Parameters:</p> Name Type Description Default <code>event_class</code> <code>type[BaseEvent]</code> <p>Event type to handle</p> required <code>handler</code> <code>Callable</code> <p>Async function(event, deps) -&gt; Optional[BaseEvent]</p> required Example <pre><code>async def my_handler(event: TokenIssuedEvent, deps: Dependencies):\n    # Custom logic\n    return None  # or return another event\n\napp.subscribe(TokenIssuedEvent, my_handler)\n</code></pre>"},{"location":"reference/#x402_mock.servers.Http402Server.add_hook","title":"<code>add_hook(event_class: type[BaseEvent], hook: Callable) -&gt; None</code>","text":"<p>Register event hook for side effects.</p> <p>Parameters:</p> Name Type Description Default <code>event_class</code> <code>type[BaseEvent]</code> <p>Event type to hook into</p> required <code>hook</code> <code>Callable</code> <p>Async function(event, deps) -&gt; None</p> required Example <pre><code>async def log_event(event, deps):\n    print(f\"Event: {event}\")\n\napp.add_hook(TokenIssuedEvent, log_event)\n</code></pre>"},{"location":"reference/#x402_mock.servers.Http402Server.hook","title":"<code>hook(event_class: type[BaseEvent]) -&gt; Callable</code>","text":"<p>Decorator for registering event hooks.</p> <p>Parameters:</p> Name Type Description Default <code>event_class</code> <code>type[BaseEvent]</code> <p>Event type to hook into</p> required Example <p>@app.hook(TokenIssuedEvent) async def on_token_issued(event, deps):     await send_analytics(event)</p>"},{"location":"reference/#x402_mock.servers.Http402Server.payment_required","title":"<code>payment_required(route_handler)</code>","text":"<p>Decorator to protect routes with payment verification.</p> <p>Returns 402 response if payment required, otherwise executes handler with verified payload.</p> Example <pre><code>@app.payment_required\n@app.get(\"/data\")\nasync def get_data(payload):\n    return {\"user\": payload[\"address\"]}\n</code></pre>"},{"location":"reference/#x402_mock.servers.generate_token","title":"<code>generate_token(*, private_key: str, expires_in: int = 3600, nonce_length: int = 16) -&gt; str</code>","text":"<p>Generate a signed token.</p> <p>Parameters:</p> Name Type Description Default <code>private_key</code> <code>str</code> <p>Secret key used to sign the token.</p> required <code>expires_in</code> <code>int</code> <p>Token lifetime in seconds.</p> <code>3600</code> <code>nonce_length</code> <code>int</code> <p>Length of random nonce.</p> <code>16</code> <p>Returns:</p> Type Description <code>str</code> <p>Signed token string.</p>"},{"location":"reference/#x402_mock.servers.verify_token","title":"<code>verify_token(*, token: str, private_key: str, leeway: int = 0) -&gt; Dict[str, object]</code>","text":"<p>Verify token signature and expiration.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>str</code> <p>Token string.</p> required <code>private_key</code> <code>str</code> <p>Secret key used to verify the token.</p> required <code>leeway</code> <code>int</code> <p>Allowed clock skew in seconds.</p> <code>0</code> <p>Returns:</p> Type Description <code>Dict[str, object]</code> <p>Decoded payload if valid.</p> <p>Raises:</p> Type Description <code>TokenExpired</code> <p>If token is expired.</p> <code>TokenInvalid</code> <p>If token is malformed or signature mismatch.</p>"},{"location":"reference/#x402_mock.servers.create_private_key","title":"<code>create_private_key(*, prefix: str = '', length: int = 32, use_special_chars: bool = False) -&gt; str</code>","text":"<p>Generate a private key with optional prefix and randomization rules.</p> <p>Parameters:</p> Name Type Description Default <code>prefix</code> <code>str</code> <p>A custom string to prepend to the random key (semi-automatic rule).</p> <code>''</code> <code>length</code> <code>int</code> <p>The number of random characters to generate.</p> <code>32</code> <code>use_special_chars</code> <code>bool</code> <p>Whether to include special characters in the random part.</p> <code>False</code> <p>Returns:</p> Type Description <code>str</code> <p>A secure private key string.</p>"},{"location":"reference/#x402_mock.servers.save_key_to_env","title":"<code>save_key_to_env(key_name: str, key_value: str, env_file: str = '.env')</code>","text":"<p>Save or update a key-value pair in a .env file.</p> <p>Parameters:</p> Name Type Description Default <code>key_name</code> <code>str</code> <p>The environment variable name (e.g., \"PRIVATE_KEY\").</p> required <code>key_value</code> <code>str</code> <p>The actual key string to save.</p> required <code>env_file</code> <code>str</code> <p>Path to the .env file. Defaults to \".env\".</p> <code>'.env'</code>"},{"location":"reference/#clients","title":"Clients","text":"<p>HTTP 402 Payment Client Middleware</p> <p>The Clients module provides an intelligent HTTP client that transparently handles HTTP 402 Payment Required responses. It extends <code>httpx.AsyncClient</code> to automatically intercept payment challenges, generate signed payment permits, exchange them for access tokens, and retry the original request\u2014all without requiring explicit user intervention.</p> <p>Key Features: - Transparent Payment Handling: Automatically processes 402 responses without manual intervention - httpx Compatibility: Fully compatible drop-in replacement for httpx.AsyncClient - Offline Signature Auto-Signing: Generates chain/token-specific offline authorizations (ERC-3009 / Permit2) using registered payment methods - Token Exchange: Automatically exchanges permits for access tokens at server endpoints - Request Retry: Seamlessly retries original requests with obtained authorization - Multi-Chain Support: Register payment capabilities across different blockchain networks</p> <p>Main Components: - <code>Http402Client</code>: Extended async HTTP client with automatic payment flow handling</p> <p>Usage Pattern: 1. Initialize client and register payment methods 2. Make standard HTTP requests to protected resources 3. Client automatically handles 402 challenges and obtains access 4. Receive successful responses transparently</p>"},{"location":"reference/#x402_mock.clients","title":"<code>x402_mock.clients</code>","text":"<p>Client module for x402 payment authorization.</p> <p>Provides easy-to-use interfaces for accessing protected resources with automatic permit signing and token exchange.</p>"},{"location":"reference/#x402_mock.clients.Http402Client","title":"<code>Http402Client</code>","text":"<p>               Bases: <code>AsyncClient</code></p> <p>Extended httpx.AsyncClient with automatic 402 payment handling.</p> <p>This client extends httpx.AsyncClient and automatically handles 402 Payment  Required status codes by: 1. Parsing payment requirements 2. Generating signed permits 3. Exchanging permits for access tokens 4. Retrying the original request with authorization</p> <p>Fully compatible with httpx.AsyncClient - supports all methods, properties, and can be used as an async context manager.</p> Usage <pre><code>async with Http402Client() as client:\n    client.add_payment_method(\"eip155:11155111\", 100.0, \"USDC\")\n    response = await client.get(\"https://api.example.com/data\")\n</code></pre>"},{"location":"reference/#x402_mock.clients.Http402Client.__init__","title":"<code>__init__(adapter_hub: Optional[AdapterHub] = None, **kwargs)</code>","text":"<p>Initialize client with optional payment adapter.</p> <p>Parameters:</p> Name Type Description Default <code>adapter_hub</code> <code>Optional[AdapterHub]</code> <p>Optional AdapterHub for payment handling</p> <code>None</code> <code>token</code> <p>Optional initial authorization token</p> required <code>**kwargs</code> <p>All standard httpx.AsyncClient arguments (timeout, headers, etc.)</p> <code>{}</code>"},{"location":"reference/#x402_mock.clients.Http402Client.add_payment_method","title":"<code>add_payment_method(payment_component: Union[PaymentComponentTypes, Dict[str, Any]]) -&gt; None</code>","text":"<p>Register local payment capability.</p> <p>This enables the middleware to automatically generate payment permits when encountering 402 responses.</p> <p>Parameters:</p> Name Type Description Default <code>payment_component</code> <code>Union[PaymentComponentTypes, Dict[str, Any]]</code> <p>A <code>PaymentComponentTypes</code> instance or a plain dict                that will be coerced into the correct type.</p> required"},{"location":"reference/#x402_mock.clients.Http402Client.request","title":"<code>request(method: str, url: httpx._types.URLTypes, **kwargs) -&gt; httpx.Response</code>  <code>async</code>","text":"<p>Execute HTTP request with automatic 402 handling.</p> <p>Overrides httpx.AsyncClient.request() to intercept 402 responses. All other httpx methods (get, post, etc.) automatically use this.</p> <p>Parameters:</p> Name Type Description Default <code>method</code> <code>str</code> <p>HTTP method (GET, POST, etc.)</p> required <code>url</code> <code>URLTypes</code> <p>Request URL</p> required <code>**kwargs</code> <p>All standard httpx arguments</p> <code>{}</code> <p>Returns:</p> Type Description <code>Response</code> <p>httpx.Response object</p>"},{"location":"reference/#adapters","title":"Adapters","text":"<p>Unified Blockchain Adapter Interface</p> <p>The Adapters module provides a unified abstraction layer that bridges differences between various blockchain platforms (EVM, Solana, etc.). It implements a plugin-based architecture with automatic blockchain type detection, enabling consistent payment permit signing, signature verification, and on-chain settlement operations across heterogeneous blockchain ecosystems.</p> <p>Key Features: - Blockchain Abstraction: Unified interface for EVM, SVM (Solana), and other blockchain platforms - Automatic Type Detection: Identifies blockchain type from chain identifiers (CAIP-2 format) - Signature Operations: Generate and verify blockchain-specific cryptographic signatures - Authorization Validation: Verify authorization authenticity, expiration, nonce, and on-chain conditions - Transaction Settlement: Execute on-chain transfers with confirmation tracking (ERC-3009 / Permit2 on EVM) - Balance Queries: Query token balances and allowances across different chains - Extensible Architecture: Factory pattern enables easy addition of new blockchain adapters</p> <p>Main Components: - <code>AdapterHub</code>: Central gateway routing operations to appropriate blockchain adapters - <code>AdapterFactory</code>: Abstract base class defining adapter interface contracts - <code>PaymentRegistry</code>: Manages payment method registration and retrieval - Platform-specific adapters: <code>EVMAdapter</code> (Ethereum/EVM chains), SVM adapter (coming soon)</p> <p>Architecture Pattern: Uses the Adapter pattern combined with Factory pattern to provide a consistent API while delegating to blockchain-specific implementations under the hood.</p>"},{"location":"reference/#x402_mock.adapters","title":"<code>x402_mock.adapters</code>","text":""},{"location":"reference/#x402_mock.adapters.AdapterHub","title":"<code>AdapterHub</code>","text":"<p>Unified Blockchain Adapter Hub.</p> <p>Provides core blockchain adapter operations with automatic type detection and routing. Manages payment component registration and delegates to blockchain-specific adapters.</p>"},{"location":"reference/#x402_mock.adapters.AdapterHub.__init__","title":"<code>__init__(evm_private_key: str = None, request_timeout: int = 60)</code>","text":"<p>Initialize the hub with a payment registry and chain-specific adapter instances.</p> <p>Parameters:</p> Name Type Description Default <code>evm_private_key</code> <code>str</code> <p>Private key used by the EVM adapter for on-chain operations.</p> <code>None</code> <code>request_timeout</code> <code>int</code> <p>HTTP request timeout (seconds) forwarded to each adapter.</p> <code>60</code>"},{"location":"reference/#x402_mock.adapters.AdapterHub.register_payment_methods","title":"<code>register_payment_methods(payment_component: Union[PaymentComponentTypes, Dict[str, Any]], client_role: bool = False) -&gt; None</code>","text":"<p>Register a payment component into the hub under the given role.</p> <p>Server role (<code>client_role=False</code>, default): if <code>pay_to</code> is not set on the component, it is automatically filled with the wallet address returned by the matching chain adapter.  Use this when the hub acts as the receiving party.</p> <p>Client role (<code>client_role=True</code>): <code>pay_to</code> is left untouched.  Use this when the hub acts as the signing/paying party and the recipient address will come from the remote server's payment requirements.</p> <p>Parameters:</p> Name Type Description Default <code>payment_component</code> <code>Union[PaymentComponentTypes, Dict[str, Any]]</code> <p>A <code>PaymentComponentTypes</code> instance or a plain dict                that will be coerced into the correct type.</p> required <code>client_role</code> <code>bool</code> <p><code>False</code> (default) for server role; <code>True</code> for client role.</p> <code>False</code> <p>Raises:</p> Type Description <code>TypeError</code> <p>If the blockchain type cannot be determined from the component,        or if no adapter is registered for that type.</p> <code>ValueError</code> <p>If the component cannot be parsed or fails chain validation.</p>"},{"location":"reference/#x402_mock.adapters.AdapterHub.get_payment_methods","title":"<code>get_payment_methods() -&gt; List[PaymentComponentTypes]</code>","text":"<p>Get all registered payment methods.</p> <p>Returns:</p> Type Description <code>List[PaymentComponentTypes]</code> <p>List of registered payment components</p>"},{"location":"reference/#x402_mock.adapters.AdapterHub.initialize","title":"<code>initialize(client_role: bool = False) -&gt; None</code>  <code>async</code>","text":"<p>One-time startup initialisation gated by caller role.</p> <p>Must be called once before signature() when operating as the signing party (client).  For each registered adapter, the chain-specific <code>client_init()</code> hook is invoked so it can ensure any required on-chain state is in place (e.g. Permit2 ERC-20 allowances for EVM).</p> <p>Server-side roles (verify_signature / settle) do not require this call and may pass <code>client_role=False</code> to skip the adapter hooks while still marking the hub as initialised for completeness.</p> <p>Parameters:</p> Name Type Description Default <code>client_role</code> <code>bool</code> <p><code>True</code> triggers adapter pre-signing setup;          <code>False</code> (default) skips the hooks (no on-chain writes needed).</p> <code>False</code> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If any adapter's client_init() fails.</p>"},{"location":"reference/#x402_mock.adapters.AdapterHub.verify_signature","title":"<code>verify_signature(permit_payload: Union[PermitTypes, Dict[str, Any]]) -&gt; Optional[Any]</code>  <code>async</code>","text":"<p>Verify permit signature with automatic blockchain detection and component matching.</p> <p>Converts permit payload to typed model, matches token with registered components, and calls corresponding adapter to verify signature.</p> <p>Parameters:</p> Name Type Description Default <code>permit_payload</code> <code>Union[PermitTypes, Dict[str, Any]]</code> <p>Permit data (PermitTypes or dict)</p> required <p>Returns:</p> Type Description <code>Optional[Any]</code> <p>Verification result from adapter</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If blockchain type cannot be determined</p> <code>ValueError</code> <p>If payload conversion or token matching fails</p>"},{"location":"reference/#x402_mock.adapters.AdapterHub.settle","title":"<code>settle(permit_payload: Union[PermitTypes, Dict[str, Any]]) -&gt; Optional[Any]</code>  <code>async</code>","text":"<p>Execute permit settlement with automatic type conversion.</p> <p>Converts permit payload to typed model and calls corresponding adapter.</p> <p>Parameters:</p> Name Type Description Default <code>permit_payload</code> <code>Union[PermitTypes, Dict[str, Any]]</code> <p>Permit data (PermitTypes or dict)</p> required <p>Returns:</p> Type Description <code>Optional[Any]</code> <p>Transaction confirmation from server adapter</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If blockchain type cannot be determined</p> <code>ValueError</code> <p>If payload conversion fails</p>"},{"location":"reference/#x402_mock.adapters.AdapterHub.signature","title":"<code>signature(list_components: List[Union[PaymentComponentTypes, Dict[str, Any]]]) -&gt; PermitTypes</code>  <code>async</code>","text":"<p>Generate signed permit from remote payment components.</p> <p>Matches remote components against local support list, converts to typed model, and delegates to blockchain-specific adapter for signing.</p> <p>Parameters:</p> Name Type Description Default <code>list_components</code> <code>List[Union[PaymentComponentTypes, Dict[str, Any]]]</code> <p>Remote payment components (typed or dict) to match              against locally registered ones.</p> required <p>Returns:</p> Type Description <code>PermitTypes</code> <p>Signed permit produced by the matching chain adapter.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If no matching component is found or type conversion fails.</p> <code>TypeError</code> <p>If the blockchain type cannot be determined.</p>"},{"location":"reference/#x402_mock.adapters.PaymentRegistry","title":"<code>PaymentRegistry</code>","text":"<p>Central registry that aggregates payment components across all supported blockchain types.</p> <p>Routes each submitted payment component to the appropriate chain-specific registry (e.g. EVM, and future chains such as Solana) and maintains a unified support list.</p>"},{"location":"reference/#x402_mock.adapters.PaymentRegistry.method_register","title":"<code>method_register(payment_component: Union[PaymentComponentTypes, Dict[str, Any]]) -&gt; None</code>","text":"<p>Register a payment component into the appropriate chain-specific registry.</p> <p>Accepts either a validated payment component instance or a raw dict that will be coerced into the correct type via Pydantic's discriminated union.</p> <p>Parameters:</p> Name Type Description Default <code>payment_component</code> <code>Union[PaymentComponentTypes, Dict[str, Any]]</code> <p>A <code>PaymentComponentTypes</code> instance or a plain dict                with the necessary fields to construct one.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If the dict cannot be parsed into a known payment component type,         or if the component fails chain-specific validation.</p>"},{"location":"reference/#x402_mock.adapters.PaymentRegistry.get_support_list","title":"<code>get_support_list() -&gt; List[PaymentComponentTypes]</code>","text":"<p>Return all registered payment components across all supported chain types.</p> <p>Returns:</p> Type Description <code>List[PaymentComponentTypes]</code> <p>An ordered list of every payment component that has been successfully registered.</p>"},{"location":"reference/#x402_mock.adapters.AdapterFactory","title":"<code>AdapterFactory</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract Base Class for Server-Side Blockchain Adapters.</p> <p>Defines the interface for server-side operations that interact directly with blockchain nodes. Server-side adapters are responsible for: - Verifying permit signatures and permit validity on-chain - Executing transactions (settle/send_transaction) on-chain - Querying token balances and other on-chain state</p> <p>Server adapters use the application's private key to sign and send transactions. They act as the bridge between the x402 system and the blockchain.</p> <p>Key Responsibilities: 1. verify_signature: Validate permit signature and check permit conditions on-chain 2. settle: Execute the permit transaction on-chain and return confirmation 3. get_balance: Query token balance of an address on-chain 4. signature: Support signing operations for blockchain-specific formats</p> Example Implementation <p>class EVMServerAdapter(AdapterServerFactory):     # EVM/Ethereum-specific implementation     pass</p> <p>class SolanaServerAdapter(AdapterServerFactory):     # Solana-specific implementation     pass</p>"},{"location":"reference/#x402_mock.adapters.AdapterFactory.verify_signature","title":"<code>verify_signature(permit: BasePermit, payment_requirement: BasePaymentComponent) -&gt; BaseVerificationResult</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Verify permit signature validity and check permit conditions on-chain.</p> <p>This is the critical security operation that ensures: 1. The permit signature is cryptographically valid 2. The recovered signer matches the permit owner 3. The permit has not expired 4. The nonce prevents replay attacks 5. The owner has sufficient balance and allowance 6. The payment amount matches or exceeds requirements</p> <p>Parameters:</p> Name Type Description Default <code>permit</code> <code>BasePermit</code> <p>BasePermit instance containing permit data and signature</p> required <code>payment_requirement</code> <code>BasePaymentComponent</code> <p>BasePaymentComponent specifying expected payment amount/conditions</p> required <p>Returns:</p> Name Type Description <code>BaseVerificationResult</code> <code>BaseVerificationResult</code> <p>Detailed verification result including: - status: Verification result status (SUCCESS, INVALID_SIGNATURE, EXPIRED, etc.) - is_valid: Boolean indicating if permit is valid - permit_owner: Verified owner address - authorized_amount: Verified authorized amount - message: Human-readable status message - blockchain_state: Optional on-chain state data</p> Implementation Notes <ul> <li>Must recover the signer from signature</li> <li>Must verify signature against permit data hash</li> <li>Must check permit.is_expired()</li> <li>Must query on-chain state (nonce, allowance, balance)</li> <li>Must validate payment amount meets requirements</li> </ul> Example <p>result = await adapter.verify_signature(permit, payment_req) if result.is_success():     # Permit is valid, proceed to settlement     await adapter.settle(permit) else:     # Return verification error to client     error_msg = result.get_error_message()</p>"},{"location":"reference/#x402_mock.adapters.AdapterFactory.settle","title":"<code>settle(permit: BasePermit) -&gt; BaseTransactionConfirmation</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Execute permit transaction on-chain (settlement/transaction execution).</p> <p>This method actually executes the token transfer on-chain using the permit signature. It should only be called after verify_signature has confirmed the permit is valid.</p> <p>Steps: 1. Construct permit() call with signature components (v, r, s) 2. Build the complete transaction (gas estimation, nonce, etc.) 3. Sign transaction with server's private key 4. Broadcast transaction to blockchain 5. Wait for transaction confirmation 6. Return transaction confirmation with hash and receipt data</p> <p>Parameters:</p> Name Type Description Default <code>permit</code> <code>BasePermit</code> <p>BasePermit instance with valid signature (assumed verified)</p> required <p>Returns:</p> Name Type Description <code>BaseTransactionConfirmation</code> <code>BaseTransactionConfirmation</code> <p>Transaction execution result including: - status: Transaction status (SUCCESS, FAILED, PENDING, etc.) - tx_hash: Transaction hash on-chain - block_number: Block number containing transaction - block_timestamp: Block timestamp - gas_used: Actual gas consumed - confirmations: Number of block confirmations - error_message: Error details if transaction failed</p> Implementation Notes <ul> <li>Estimate gas before sending</li> <li>Sign transaction with server private key</li> <li>Handle blockchain-specific transaction formats</li> <li>Wait for configurable number of confirmations</li> <li>Handle network errors gracefully</li> </ul> Example <p>result = await adapter.settle(permit) if result.is_success():     print(f\"Settlement complete: {result.tx_hash}\")     # Update database with tx_hash else:     print(f\"Settlement failed: {result.error_message}\")</p>"},{"location":"reference/#x402_mock.adapters.AdapterFactory.get_balance","title":"<code>get_balance(address: str) -&gt; int</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Query token balance for an address on the blockchain.</p> <p>Retrieves the current balance of the configured token (typically USDC) for the given address. This is used for: - Verification: Check owner has sufficient balance - Queries: Allow clients to check addresses' balances</p> <p>Parameters:</p> Name Type Description Default <code>address</code> <code>str</code> <p>Wallet address to query (blockchain format, e.g., \"0x...\" for EVM)</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Token balance in smallest units (e.g., wei for EVM where 1 USDC = 1e6)  Returns 0 if address has no balance</p> Implementation Notes <ul> <li>Use blockchain node RPC call (balanceOf for ERC20)</li> <li>Handle address validation/checksum</li> <li>Cache results if possible for performance</li> <li>Handle blockchain-specific address formats</li> </ul> Example <p>balance = await adapter.get_balance(\"0x1234...5678\")</p>"},{"location":"reference/#x402_mock.adapters.AdapterFactory.get_balance--balance-1000000-representing-1-usdc-with-6-decimals","title":"balance = 1000000 (representing 1 USDC with 6 decimals)","text":""},{"location":"reference/#x402_mock.adapters.AdapterFactory.signature","title":"<code>signature(payment_component: BasePaymentComponent) -&gt; BasePermit</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Generate complete signed permit from payment component.</p> <p>This method builds the permit message, signs it with user's private key/wallet, and returns a fully signed and ready-to-submit permit object. All permit parameters are derived from the payment_component.</p> <p>Parameters:</p> Name Type Description Default <code>payment_component</code> <code>BasePaymentComponent</code> <p>BasePaymentComponent specifying payment requirements,                blockchain type, and all permit parameters</p> required <p>Returns:</p> Name Type Description <code>BasePermit</code> <code>BasePermit</code> <p>Fully signed permit ready for server submission. For EVM, this is EIP2612Permit with: - owner: Token owner address - spender: Authorized spender address - token: Token contract address - value: Authorized amount - deadline: Permit expiration timestamp - nonce: Replay attack prevention nonce - signature: EIP2612PermitSignature with v, r, s components - permit_type: Blockchain-specific type (e.g., \"EIP2612\")</p> Implementation Notes <ul> <li>Extract all permit parameters from payment_component</li> <li>Must validate payment_component matches the adapter's blockchain type</li> <li>Must build blockchain-specific permit message internally</li> <li>Must sign with user's private key (not server's)</li> <li>Must validate signature format before returning</li> <li>Must return complete permit with signature components</li> <li>Should not leak private key</li> </ul> <p>Raises:</p> Type Description <code>TypeError</code> <p>If payment_component blockchain type doesn't match adapter</p> <code>ValueError</code> <p>If payment_component is invalid or signing fails</p> Example <p>adapter = EVMClientAdapter() payment = EVMPaymentComponent(payment_type=\"evm\", ...) permit = await adapter.signature(payment_component=payment)</p>"},{"location":"reference/#x402_mock.adapters.AdapterFactory.signature--permit-now-contains-complete-signed-data-ready-to-send-to-server","title":"permit now contains complete signed data ready to send to server","text":"<p>await server.settle(permit)</p>"},{"location":"reference/#x402_mock.adapters.AdapterFactory.client_init","title":"<code>client_init(payment_components: List[BasePaymentComponent]) -&gt; None</code>  <code>async</code>","text":"<p>One-time client-side pre-signing initialisation hook.</p> <p>Called by AdapterHub.initialize(role=\"client\") once at startup, before any signature() calls are made.  Concrete adapters should override this to perform chain-specific on-chain setup required by the signing role (e.g. ERC-20 allowance approval for Permit2 on EVM, SPL token delegation on SVM).  The default implementation is a no-op so that server-only adapters and future adapters can inherit without modification.</p> <p>Parameters:</p> Name Type Description Default <code>payment_components</code> <code>List[BasePaymentComponent]</code> <p>All payment components registered via register_payment_methods(). The implementation may filter these down to the subset it manages.</p> required <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If any required on-chain setup fails.</p>"},{"location":"reference/#x402_mock.adapters.AdapterFactory.get_wallet_address","title":"<code>get_wallet_address() -&gt; str</code>  <code>abstractmethod</code>","text":"<p>Get server wallet address from private key.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Server wallet address in checksum format</p>"},{"location":"reference/#x402_mock.adapters.EVMAdapter","title":"<code>EVMAdapter</code>","text":"<p>               Bases: <code>AdapterFactory</code></p> <p>EVM Blockchain Server Adapter Implementation.</p> <p>Provides complete server-side functionality for EVM blockchains including: - EIP2612 permit signature verification - On-chain state validation (nonce, allowance, balance, expiration) - Token transfer execution via signed permits - Balance and allowance queries</p> <p>This adapter validates all security constraints before executing any on-chain operations. All methods are designed to return clear, actionable error messages rather than raising exceptions.</p> <p>Key Design Features: - Dynamic RPC URL selection based on permit's chain_id - Environment-aware infrastructure key handling (evm_infra_key for premium RPC, falls back to public) - Private key loaded from environment (evm_private_key) during initialization - Lazy Web3 instance creation per blockchain interaction (ensures correct RPC endpoint)</p> <p>Attributes:</p> Name Type Description <code>account</code> <p>Server's account object (initialized from evm_private_key environment variable)</p> <code>address</code> <p>Checksum-formatted server account address</p> <code>_infra_key</code> <p>Optional infrastructure API key for premium RPC endpoints</p> Environment Variables <ul> <li>evm_private_key: Server's EVM private key for signing transactions (required)</li> <li>evm_infra_key: Optional infrastructure API key (e.g., Alchemy/Infura key)                 If not set, falls back to public RPC endpoints</li> </ul> Example"},{"location":"reference/#x402_mock.adapters.EVMAdapter--initialize-with-environment-variables","title":"Initialize with environment variables","text":"<p>adapter = EVMServerAdapter()  # Loads evm_private_key automatically</p>"},{"location":"reference/#x402_mock.adapters.EVMAdapter--or-explicitly-provide-private-key-for-testing","title":"Or explicitly provide private key (for testing)","text":"<p>adapter = EVMServerAdapter(private_key=\"0x...\")</p>"},{"location":"reference/#x402_mock.adapters.EVMAdapter--verify-permit-signature-and-on-chain-state","title":"Verify permit signature and on-chain state","text":"<p>result = await adapter.verify_signature(permit, payment_requirement) if result.is_success():     # Execute the permit on-chain     confirmation = await adapter.settle(permit)</p>"},{"location":"reference/#x402_mock.adapters.EVMAdapter.__init__","title":"<code>__init__(*, private_key: Optional[str] = None, request_timeout: int = 60)</code>","text":"<p>Initialize EVM Server Adapter with environment-aware configuration.</p> <p>This constructor implements a flexible initialization pattern: 1. Accepts optional <code>private_key</code> parameter (useful for testing). 2. Falls back to the <code>evm_private_key</code> environment variable if not provided. 3. Initializes the server account object from the resolved private key.</p> <p>Token address and RPC URL are not stored at initialization time.  They are supplied call-by-call via the <code>rpc_url</code> field of :class:<code>EVMPaymentComponent</code> (or the permit object) during :meth:<code>verify_signature</code> and :meth:<code>settle</code>.  This design lets a single adapter instance handle arbitrary EVM networks without reconfiguration.</p> <p>Parameters:</p> Name Type Description Default <code>private_key</code> <code>Optional[str]</code> <p>Server's private key in 0x-prefixed hex format.  When omitted, the value of the <code>evm_private_key</code> environment variable is used.</p> <code>None</code> <code>request_timeout</code> <code>int</code> <p>HTTP request timeout in seconds passed to every :class:<code>AsyncWeb3</code> provider created by this instance (default <code>60</code>).</p> <code>60</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If neither <code>private_key</code> nor the <code>evm_private_key</code> environment variable is present, or if the key format is invalid.</p>"},{"location":"reference/#x402_mock.adapters.EVMAdapter.signature","title":"<code>signature(payment_component: EVMPaymentComponent) -&gt; Union[ERC3009Authorization, Permit2Signature]</code>  <code>async</code>","text":"<p>Generate a signed authorization for the given payment component.</p> <p>Scheme selection is based on the payment component's <code>currency</code>: - USDC, EURC (and other ERC-3009 compatible tokens): ERC-3009   <code>transferWithAuthorization</code> is preferred. - All other tokens: Permit2 <code>permitTransferFrom</code> is used as fallback.</p> <p>Signing is performed entirely in-process via <code>sign_universal</code>.  The chain ID is parsed from <code>payment_component.caip2</code> via <code>parse_caip2_eip155_chain_id</code>; no <code>metadata</code> dict is accessed.</p> <p>Parameters:</p> Name Type Description Default <code>payment_component</code> <code>EVMPaymentComponent</code> <p>:class:<code>EVMPaymentComponent</code> supplying all required signing parameters as first-class fields:</p> <ul> <li><code>token</code> \u2014 ERC-20 contract address to authorize.</li> <li><code>caip2</code> \u2014 CAIP-2 chain identifier (e.g. <code>\"eip155:11155111\"</code>);   the numeric chain ID is extracted automatically.</li> <li><code>pay_to</code> \u2014 recipient / spender address that receives the   authorization (server wallet address on the counterparty side).</li> <li><code>amount</code> \u2014 human-readable payment amount (e.g. <code>1.5</code> for   1.5 USDC); converted to smallest token units using   <code>token_decimals</code>.</li> <li><code>token_decimals</code> \u2014 decimal precision of the token (e.g. <code>6</code>   for USDC).</li> <li><code>currency</code> \u2014 currency code used to select the signing scheme   (e.g. <code>\"USDC\"</code> triggers ERC-3009; others fall back to Permit2).</li> <li><code>token_name</code> \u2014 EIP-712 domain name of the token contract   (required for ERC-3009 domain separator; unused for Permit2).</li> <li><code>token_version</code> \u2014 EIP-712 domain version string (required for   ERC-3009; unused for Permit2).</li> </ul> required <p>Returns:</p> Type Description <code>Union[ERC3009Authorization, Permit2Signature]</code> <p><code>ERC3009Authorization</code> when the currency supports ERC-3009;</p> <code>Union[ERC3009Authorization, Permit2Signature]</code> <p><code>Permit2Signature</code> otherwise.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the chain is unsupported or required fields are invalid.</p> <code>TypeError</code> <p>If the private key is not available.</p>"},{"location":"reference/#x402_mock.adapters.EVMAdapter.verify_signature","title":"<code>verify_signature(permit: Union[ERC3009Authorization, Permit2Signature], payment_requirement: EVMPaymentComponent) -&gt; EVMVerificationResult</code>  <code>async</code>","text":"<p>Verify a signed authorization and validate payment constraints.</p> <p>Accepts the direct output of :meth:<code>signature</code> \u2014 either an <code>ERC3009Authorization</code> or a <code>Permit2Signature</code> \u2014 and verifies it using :func:<code>verify_universal</code>.</p>"},{"location":"reference/#x402_mock.adapters.EVMAdapter.verify_signature--validation-steps","title":"Validation steps","text":"<ol> <li>Type check - <code>permit</code> must be <code>ERC3009Authorization</code> or    <code>Permit2Signature</code>.</li> <li>Receiver check - the <code>recipient</code> / <code>spender</code> field must    match the server's wallet address.</li> <li>Amount check - the authorized value (smallest token unit) must    be <code>&gt;=</code> the required amount derived from    <code>payment_requirement.amount</code> (human-readable USDC).</li> <li>Balance check - the on-chain token balance of the sender must    cover the required amount.</li> <li>Signature + expiry - delegates to :func:<code>verify_universal</code>,    which reconstructs the EIP-712 struct, recovers the signer, and    checks the time window / deadline.</li> </ol>"},{"location":"reference/#x402_mock.adapters.EVMAdapter.verify_signature--amount-conversion","title":"Amount conversion","text":"<p><code>payment_requirement.amount</code> is a human-readable USDC quantity (e.g. <code>1.5</code> for 1.5 USDC).  It is converted to the smallest token unit via :func:<code>amount_to_value</code> using <code>payment_requirement.metadata [\"decimals\"]</code> (defaults to <code>6</code> for USDC).</p> <p>Parameters:</p> Name Type Description Default <code>permit</code> <code>Union[ERC3009Authorization, Permit2Signature]</code> <p>ERC3009Authorization or Permit2Signature produced by :meth:<code>signature</code>.</p> required <code>payment_requirement</code> <code>EVMPaymentComponent</code> <p>EVMPaymentComponent describing the expected payment (human-readable <code>amount</code>, <code>decimals</code> in metadata).</p> required <p>Returns:</p> Type Description <code>EVMVerificationResult</code> <p>EVMVerificationResult with <code>is_valid=True</code> and</p> <code>EVMVerificationResult</code> <p><code>status=SUCCESS</code> if all checks pass; otherwise a descriptive</p> <code>EVMVerificationResult</code> <p>failure result.  No exceptions are raised.</p>"},{"location":"reference/#x402_mock.adapters.EVMAdapter.settle","title":"<code>settle(permit: Union[ERC3009Authorization, Permit2Signature]) -&gt; EVMTransactionConfirmation</code>  <code>async</code>","text":"<p>Execute on-chain token transfer to settle a payment authorization.</p> <p>Dispatches to the appropriate settlement strategy based on permit type:</p> <ul> <li>ERC3009Authorization \u2192 calls <code>transferWithAuthorization</code> directly   on the token contract (ERC-3009 path, supported by USDC / EURC).</li> <li>Permit2Signature \u2192 calls <code>permitTransferFrom</code> on the Uniswap   Permit2 singleton contract.</li> </ul> <p>Both paths share the same receipt-polling and confirmation-building logic via :meth:<code>_send_and_confirm</code>.</p> <p>Chain handling is fully dynamic: the Web3 RPC instance is resolved from <code>permit.chain_id</code> at call time, with optional premium infra key.</p> <p>Parameters:</p> Name Type Description Default <code>permit</code> <code>Union[ERC3009Authorization, Permit2Signature]</code> <p>Signed authorization produced by :meth:<code>signature</code> \u2014 either <code>ERC3009Authorization</code> or <code>Permit2Signature</code>.</p> required <p>Returns:</p> Type Description <code>EVMTransactionConfirmation</code> <p>class:<code>EVMTransactionConfirmation</code> with <code>status=SUCCESS</code> and</p> <code>EVMTransactionConfirmation</code> <p>populated receipt fields on success, or a descriptive failure result.</p> <code>EVMTransactionConfirmation</code> <p>No exceptions are raised; all errors are captured in the return value.</p>"},{"location":"reference/#x402_mock.adapters.EVMAdapter.get_balance","title":"<code>get_balance(address: str, token_address: Optional[str] = None, web3: Optional[AsyncWeb3] = None) -&gt; int</code>  <code>async</code>","text":"<p>Query token balance for an address on-chain.</p> <p>This method is designed to work in two modes: 1. With explicit parameters (token_address and web3) - for internal use 2. With just address - for external API use (not recommended without context)</p> <p>Parameters:</p> Name Type Description Default <code>address</code> <code>str</code> <p>Wallet address to query (0x-prefixed hex format)</p> required <code>token_address</code> <code>Optional[str]</code> <p>Token contract address (optional, for explicit chain/token context)</p> <code>None</code> <code>web3</code> <code>Optional[AsyncWeb3]</code> <p>AsyncWeb3 instance (optional, created dynamically if not provided)</p> <code>None</code> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Token balance in smallest units (0 if address has no balance or error occurs)</p> Note <p>When called from external code without token_address and web3, the method cannot determine which chain to query. Consider refactoring external calls to provide these parameters explicitly.</p>"},{"location":"reference/#x402_mock.adapters.EVMAdapter.get_wallet_address","title":"<code>get_wallet_address() -&gt; str</code>","text":"<p>Get server wallet address from private key.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Server wallet address in checksum format</p>"},{"location":"reference/#x402_mock.adapters.EVMAdapter.permit2_approve","title":"<code>permit2_approve(chain_id: int, token_addr: str, values: int) -&gt; Tuple[str, Optional[TxReceipt]]</code>  <code>async</code>","text":"<p>Asynchronously signs and broadcasts an ERC20 approve transaction.</p> <p>Parameters:</p> Name Type Description Default <code>chain_id</code> <code>int</code> <p>The EVM chain ID (e.g., 1 for Ethereum, 11155111 for Sepolia).</p> required <code>token_addr</code> <code>str</code> <p>The contract address of the ERC20 token.</p> required <code>values</code> <code>int</code> <p>The raw amount (in wei) to approve.</p> required"},{"location":"reference/#x402_mock.adapters.EVMAdapter.client_init","title":"<code>client_init(payment_components: List[BasePaymentComponent]) -&gt; None</code>  <code>async</code>","text":"<p>EVM-specific client-side pre-signing initialisation.</p> <p>Iterates all registered EVMPaymentComponents and, for each currency that requires the Permit2 protocol (i.e. is NOT natively ERC-3009), queries the current ERC-20 allowance granted to the Permit2 singleton. If the allowance is below <code>_LOW_ALLOWANCE_THRESHOLD</code>, an on-chain <code>approve(permit2, uint256_max)</code> transaction is broadcast and awaited before returning.</p> <p>This must be called once at startup (via AdapterHub.initialize()) before any signature() calls are made.  Skipped automatically for ERC-3009 currencies (USDC, EURC, \u2026) because those use gasless transferWithAuthorization and do not require a prior on-chain approval.</p> <p>Parameters:</p> Name Type Description Default <code>payment_components</code> <code>List[BasePaymentComponent]</code> <p>All components returned by register_payment_methods().  Non-EVM items are silently skipped.</p> required <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If any approval transaction is broadcast but reverts on-chain (propagated from approve_erc20).</p> <code>Web3Exception</code> <p>If the RPC allowance query fails.</p>"},{"location":"reference/#x402_mock.adapters.EVMPaymentComponent","title":"<code>EVMPaymentComponent</code>","text":"<p>               Bases: <code>BasePaymentComponent</code></p> <p>EVM-Specific Payment Component.</p> <p>Extends BasePaymentComponent with EVM-specific payment requirements including token contract address, chain identifier (CAIP-2), and an optional recipient address. Typically used for USDC payments on EVM networks (Ethereum, Sepolia, etc.).</p> <p>Attributes:</p> Name Type Description <code>payment_type</code> <code>Literal['evm']</code> <p>Always \"evm\" for this implementation</p> <code>amount</code> <code>float</code> <p>Payment amount for human readability (e.g., 1.0 for 1 USDC)</p> <code>currency</code> <code>str</code> <p>Currency code (typically \"USD\" for stablecoins)</p> <code>metadata</code> <code>Dict[str, Any]</code> <p>Additional payment metadata (may include gas limits, fees, etc.)</p> <code>created_at</code> <code>datetime</code> <p>Timestamp when payment component was created</p> <code>token</code> <code>str | None</code> <p>Token contract address on specific EVM chain (EVM-specific)</p> <code>caip2</code> <code>str</code> <p>CAIP-2 chain identifier (e.g., \"eip155:1\", \"eip155:11155111\") (EVM-specific)</p> <code>pay_to</code> <code>str | None</code> <p>Optional recipient address to pay to (EVM-specific)</p> <code>rpc_url</code> <code>str | None</code> <p>Optional EVM RPC URL for this payment (EVM-specific)</p> <code>token_name</code> <code>str | None</code> <p>Optional token name (e.g., \"USDC\") (EVM-specific)</p> <code>token_decimals</code> <code>str | int | None</code> <p>Optional token decimals (string or int) (EVM-specific)</p> <code>token_version</code> <code>str | int | None</code> <p>Optional token version (string or int) (EVM-specific)</p> Example <p>payment = EVMPaymentComponent(     payment_type=\"evm\",     amount=1.0,  # 1 USDC     currency=\"USD\",     token=\"0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48\",     caip2=\"eip155:11155111\",     metadata={\"gas_price\": \"20\", \"priority_fee\": \"2\"} )</p>"},{"location":"reference/#x402_mock.adapters.EVMPaymentComponent.validate_payment","title":"<code>validate_payment() -&gt; bool</code>","text":"<p>Validate EVM payment specification.</p> <p>Checks that: - payment_type is \"evm\"  - amount is non-negative - token is valid EVM address format (0x...) - caip2 is a valid CAIP-2 identifier for EVM chains (eip155:) - pay_to is either None or a valid EVM address format (0x...) <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if payment specification is valid</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>With descriptive message if validation fails</p>"},{"location":"reference/#x402_mock.adapters.EVMVerificationResult","title":"<code>EVMVerificationResult</code>","text":"<p>               Bases: <code>BaseVerificationResult</code></p> <p>Unified EVM signature verification result.</p> <p>Covers all EVM signing schemes (ERC-3009, Permit2, EIP-2612).  Uses scheme-neutral field names that mirror <code>sign_universal</code> / <code>verify_universal</code>:</p> <p>Attributes:</p> Name Type Description <code>verification_type</code> <code>Literal['evm']</code> <p>Always <code>\"evm\"</code>.</p> <code>sender</code> <code>Optional[str]</code> <p>Token owner / authorizer address that produced the                signature.</p> <code>receiver</code> <code>Optional[str]</code> <p>Destination / authorised spender address.</p> <code>authorized_amount</code> <code>Optional[int]</code> <p>Transfer amount in the token's smallest unit.</p> <code>blockchain_state</code> <code>Optional[Dict[str, Any]]</code> <p>Optional on-chain state snapshot (balance, nonce,                allowance, etc.).</p>"},{"location":"reference/#x402_mock.adapters.EVMTransactionConfirmation","title":"<code>EVMTransactionConfirmation</code>","text":"<p>               Bases: <code>BaseTransactionConfirmation</code></p> <p>EVM-Specific Transaction Confirmation.</p> <p>Extends BaseTransactionConfirmation with EVM-specific transaction receipt data. Returned by EVMServerAdapter.settle() method.</p> <p>Attributes:</p> Name Type Description <code>confirmation_type</code> <code>Literal['evm']</code> <p>Always \"evm\" for this implementation</p> <code>status</code> <code>TransactionStatus</code> <p>Transaction execution status (inherited from BaseTransactionConfirmation)</p> <code>execution_time</code> <code>Optional[float]</code> <p>Time taken to confirm transaction (seconds) (inherited from BaseTransactionConfirmation)</p> <code>confirmations</code> <code>int</code> <p>Number of block confirmations (inherited from BaseTransactionConfirmation)</p> <code>error_message</code> <code>Optional[str]</code> <p>Error details if transaction failed (inherited from BaseTransactionConfirmation)</p> <code>logs</code> <code>Optional[List[Dict[str, Any]]]</code> <p>Transaction logs/events (inherited from BaseTransactionConfirmation)</p> <code>created_at</code> <code>datetime</code> <p>Timestamp when confirmation was recorded (inherited from BaseTransactionConfirmation)</p> <code>tx_hash</code> <code>str</code> <p>Transaction hash (0x-prefixed hex string on EVM)</p> <code>block_number</code> <code>Optional[int]</code> <p>Block number containing transaction</p> <code>block_timestamp</code> <code>Optional[int]</code> <p>Block timestamp (Unix)</p> <code>gas_used</code> <code>Optional[int]</code> <p>Actual gas consumed by transaction</p> <code>gas_limit</code> <code>Optional[int]</code> <p>Gas limit specified for transaction</p> <code>transaction_fee</code> <code>Optional[int]</code> <p>Amount of ETH/native token paid as transaction fee (in wei)</p> <code>from_address</code> <code>Optional[str]</code> <p>Transaction sender address</p> <code>to_address</code> <code>Optional[str]</code> <p>Transaction receiver/contract address</p> Example <p>confirmation = await evm_adapter.settle(permit) if confirmation.is_success():     print(f\"Settlement confirmed: {confirmation.tx_hash}\")     print(f\"Gas used: {confirmation.gas_used}\") else:     print(f\"Settlement failed: {confirmation.error_message}\")</p>"},{"location":"reference/#x402_mock.adapters.get_adapter_type","title":"<code>get_adapter_type(obj: Union[PermitTypes, PaymentComponentTypes, SignatureTypes, VerificationResultTypes, TransactionConfirmationTypes, BasePermit, BasePaymentComponent, BaseVerificationResult, BaseTransactionConfirmation]) -&gt; Optional[str]</code>","text":"<p>Retrieve the unified adapter type identifier for a given permit, payment component,  signature, verification result, or transaction confirmation.</p> <p>Automatically extracts the type discriminator field (permit_type, payment_type,  signature_type, verification_type, or confirmation_type) from the object and returns  the standardized adapter type string that can be used as a key in  AdapterHub._adapter_factories.</p> <p>This function maps all blockchain-specific discriminator values to their unified adapter type identifiers (e.g., \"EIP2612\" -&gt; \"evm\", \"polygon\" -&gt; \"evm\", \"spl\" -&gt; \"svm\").</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>Union[PermitTypes, PaymentComponentTypes, SignatureTypes, VerificationResultTypes, TransactionConfirmationTypes, BasePermit, BasePaymentComponent, BaseVerificationResult, BaseTransactionConfirmation]</code> <p>A permit, payment component, signature, verification result, or transaction  confirmation instance containing a type discriminator field. Supports both   typed instances and base classes.</p> required <p>Returns:</p> Type Description <code>Optional[str]</code> <p>The unified adapter type string (e.g., \"evm\", \"svm\") that corresponds to</p> <code>Optional[str]</code> <p>the object's blockchain type. Returns None if no matching adapter type is found.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; # EIP-2612 permit maps to \"evm\"\n&gt;&gt;&gt; permit = EIP2612Permit(permit_type=\"EIP2612\", owner=\"0x...\", ...)\n&gt;&gt;&gt; adapter_type = get_adapter_type(permit)  # Returns \"evm\"\n&gt;&gt;&gt; adapter = hub._adapter_factories[adapter_type]\n</code></pre> <pre><code>&gt;&gt;&gt; # EVM payment component maps to \"evm\"\n&gt;&gt;&gt; component = EVMPaymentComponent(payment_type=\"evm\", token=\"0x...\", ...)\n&gt;&gt;&gt; adapter_type = get_adapter_type(component)  # Returns \"evm\"\n&gt;&gt;&gt; adapter = hub._adapter_factories[adapter_type]\n</code></pre> <pre><code>&gt;&gt;&gt; # EVM verification result maps to \"evm\"\n&gt;&gt;&gt; result = EVMVerificationResult(verification_type=\"evm\", ...)\n&gt;&gt;&gt; adapter_type = get_adapter_type(result)  # Returns \"evm\"\n</code></pre> <pre><code>&gt;&gt;&gt; # Polygon payment also maps to \"evm\"\n&gt;&gt;&gt; component = EVMPaymentComponent(payment_type=\"polygon\", ...)\n&gt;&gt;&gt; adapter_type = get_adapter_type(component)  # Returns \"evm\"\n</code></pre> Note <p>The type mapping is lazily initialized on first call to avoid circular imports. To add support for new blockchains, update _initialize_adapter_type_mapping() with new type mappings in ADAPTER_TYPE_MAPPING.</p>"},{"location":"reference/#schemas","title":"Schemas","text":"<p>Base Schema Models and Type System</p> <p>The Schemas module defines the foundational type system and data models that underpin the entire x402_mock framework. It provides RFC8785-compliant Pydantic models for cryptographic operations, abstract base classes ensuring type safety across blockchain implementations, and standardized HTTP protocol message formats.</p> <p>Key Features: - RFC8785 Compliance: Canonical JSON serialization for deterministic signature generation - Type Safety: Pydantic-based validation with comprehensive type hints - Abstract Base Classes: Define contracts for permits, signatures, verification results, and confirmations - Protocol Messages: Standardized HTTP 402 request/response payload schemas - Version Management: Protocol version negotiation and compatibility handling - Blockchain Agnostic: Base models inherited by all blockchain-specific implementations</p> <p>Main Components: - <code>CanonicalModel</code>: RFC8785-compliant base model with deterministic JSON serialization - Abstract types: <code>BasePermit</code>, <code>BaseSignature</code>, <code>BaseVerificationResult</code>, <code>BaseTransactionConfirmation</code> - HTTP protocol: <code>ClientRequestHeader</code>, <code>Server402ResponsePayload</code>, <code>ClientTokenRequest</code>, <code>ServerTokenResponse</code> - Payment models: <code>BasePaymentComponent</code> defining payment requirements - Status enums: <code>VerificationStatus</code>, <code>TransactionStatus</code> - Version handling: <code>ProtocolVersion</code>, <code>SupportedVersions</code></p> <p>Purpose: Serves as the type foundation ensuring consistent data structures and validations across servers, clients, adapters, and engine components.</p>"},{"location":"reference/#x402_mock.schemas","title":"<code>x402_mock.schemas</code>","text":""},{"location":"reference/#x402_mock.schemas.CanonicalModel","title":"<code>CanonicalModel</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>RFC8785-compliant Pydantic base model with canonical JSON serialization.</p> <p>This model ensures consistent, deterministic JSON representation suitable for cryptographic operations, signature verification, and hashing.</p> Features <ul> <li>Automatic conversion of Pydantic objects, enums, and Decimals to standard types</li> <li>Deterministic key sorting in JSON output</li> <li>No extra whitespace for consistent hashing and signature verification</li> <li>RFC8785 compliance for canonical JSON representation</li> </ul> <p>All schema models should inherit from this class to ensure consistent serialization across the system.</p> Example <p>class MyModel(CanonicalModel):     name: str     value: int</p> <p>model = MyModel(name=\"test\", value=123) canonical_json = model.to_canonical_json()  # Guaranteed consistent format</p>"},{"location":"reference/#x402_mock.schemas.CanonicalModel.to_canonical_json","title":"<code>to_canonical_json() -&gt; str</code>","text":"<p>Convert model to RFC8785-compliant canonical JSON string.</p> <p>This method ensures that the JSON representation is: 1. Deterministically ordered (sorted keys) 2. Whitespace-minimal (compact format) 3. Suitable for cryptographic operations</p> <p>The conversion process: 1. model_dump(mode=\"json\") converts Pydantic objects, enums, and Decimals    to standard Python types (str, int, float, etc.) 2. json.dumps with separators and sort_keys ensures RFC8785 compliance</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>RFC8785-compliant JSON string with sorted keys and no extra whitespace.</p> Example <p>model = MyModel(name=\"test\", value=123) json_str = model.to_canonical_json()</p>"},{"location":"reference/#x402_mock.schemas.CanonicalModel.to_canonical_json--returns-nametestvalue123","title":"Returns: '{\"name\":\"test\",\"value\":123}'","text":""},{"location":"reference/#x402_mock.schemas.CanonicalModel.to_dict","title":"<code>to_dict() -&gt; Dict[str, Any]</code>","text":"<p>Convert model to dictionary representation.</p> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dict[str, Any]: Dictionary with all model fields.</p>"},{"location":"reference/#x402_mock.schemas.BaseSignature","title":"<code>BaseSignature</code>","text":"<p>               Bases: <code>CanonicalModel</code>, <code>ABC</code></p> <p>Abstract base class for blockchain signature components.</p> <p>This class defines the interface that all blockchain-specific signature implementations must follow. Different blockchains use different signature formats (e.g., EIP2612 for EVM uses v/r/s, Solana uses 64-byte signature).</p> <p>All concrete signature classes should inherit from this base class and implement the abstract methods to ensure consistent signature handling across the system.</p> <p>Attributes:</p> Name Type Description <code>signature_type</code> <code>str</code> <p>The type of signature (e.g., \"EIP2612\", \"Solana\")</p> <code>created_at</code> <code>datetime</code> <p>Timestamp when the signature was created</p> <p>Methods:</p> Name Description <code>validate_format</code> <p>Check if signature format is valid for the blockchain</p> <code>to_dict</code> <p>Convert signature to dictionary (inherited from CanonicalModel)</p>"},{"location":"reference/#x402_mock.schemas.BaseSignature.validate_format","title":"<code>validate_format() -&gt; bool</code>","text":"<p>Validate the signature format for the specific blockchain.</p> <p>This method should check that all signature components are in valid format for the target blockchain. For example: - EIP2612: Check v is 27 or 28, r and s are 64 hex chars - Solana: Check signature is 64 bytes</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if signature format is valid, False otherwise.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If signature format is invalid with descriptive message.</p>"},{"location":"reference/#x402_mock.schemas.BasePermit","title":"<code>BasePermit</code>","text":"<p>               Bases: <code>CanonicalModel</code>, <code>ABC</code></p> <p>Abstract base class for blockchain permit/approval mechanisms.</p> <p>A permit is a signed message that authorizes a spender to transfer tokens on behalf of the token owner. Different blockchains implement permits differently (EIP2612 for EVM, etc.).</p> <p>This base class provides the minimal common fields across all permit types. Blockchain-specific implementations should extend this class and add their specific fields such as owner, spender, token, value, and nonce.</p> <p>Attributes:</p> Name Type Description <code>permit_type</code> <code>str</code> <p>Type of permit (e.g., \"EIP2612\", \"Solana\")</p> <code>signature</code> <code>Optional[BaseSignature]</code> <p>Signature components for permit authorization</p> <code>created_at</code> <code>datetime</code> <p>Timestamp when permit was created</p> <p>Methods:</p> Name Description <code>validate_structure</code> <p>Validate permit structure (blockchain-specific)</p>"},{"location":"reference/#x402_mock.schemas.BasePermit.validate_structure","title":"<code>validate_structure() -&gt; bool</code>","text":"<p>Validate the permit structure and required fields for the blockchain.</p> <p>Should check that all required fields are present and in valid format for the specific blockchain permit type.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if permit structure is valid, False otherwise.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If permit structure is invalid with descriptive message.</p>"},{"location":"reference/#x402_mock.schemas.BasePaymentComponent","title":"<code>BasePaymentComponent</code>","text":"<p>               Bases: <code>CanonicalModel</code>, <code>ABC</code></p> <p>Abstract base class for payment requirement specifications.</p> <p>Payment components define what payment is expected: the amount, currency, and any additional payment-related constraints or metadata. Blockchain-specific implementations (e.g., EVM, SVM) should extend this class and add their specific fields such as token addresses.</p> <p>Attributes:</p> Name Type Description <code>payment_type</code> <code>str</code> <p>Type of payment (e.g., \"evm\", \"svm\")</p> <code>amount</code> <code>float</code> <p>Payment amount for human readability</p> <code>currency</code> <code>str</code> <p>Currency code (e.g., \"USD\", \"ETH\")</p> <code>metadata</code> <code>Dict[str, Any]</code> <p>Additional payment-related metadata</p> <code>created_at</code> <code>datetime</code> <p>Timestamp when payment component was created</p>"},{"location":"reference/#x402_mock.schemas.BasePaymentComponent.validate_payment","title":"<code>validate_payment() -&gt; bool</code>","text":"<p>Validate the payment specification.</p> <p>Should check that payment type, amount, and token are valid and compatible with the system requirements.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if payment specification is valid, False otherwise.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If payment specification is invalid with descriptive message.</p>"},{"location":"reference/#x402_mock.schemas.VerificationStatus","title":"<code>VerificationStatus</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Enumeration of possible verification result statuses.</p> <p>Attributes:</p> Name Type Description <code>SUCCESS</code> <p>Permit signature is valid and verification passed</p> <code>INVALID_SIGNATURE</code> <p>Signature is invalid or signer mismatch</p> <code>EXPIRED</code> <p>Permit deadline has passed</p> <code>INSUFFICIENT_ALLOWANCE</code> <p>Authorized amount is insufficient</p> <code>INSUFFICIENT_BALANCE</code> <p>Token balance insufficient for transaction</p> <code>REPLAY_ATTACK</code> <p>Nonce indicates potential replay attack</p> <code>BLOCKCHAIN_ERROR</code> <p>Error querying blockchain state</p> <code>UNKNOWN_ERROR</code> <p>Unexpected error during verification</p>"},{"location":"reference/#x402_mock.schemas.BaseVerificationResult","title":"<code>BaseVerificationResult</code>","text":"<p>               Bases: <code>CanonicalModel</code>, <code>ABC</code></p> <p>Abstract base class for permit signature verification results.</p> <p>This class encapsulates the result of verifying a permit signature and checking permit validity on-chain. It provides a standard interface for reporting verification status, success/failure details, and diagnostic information.</p> <p>Attributes:</p> Name Type Description <code>verification_type</code> <code>str</code> <p>Type of verification (e.g., \"evm\", \"svm\")</p> <code>status</code> <code>VerificationStatus</code> <p>Verification result status (VerificationStatus enum)</p> <code>is_valid</code> <code>bool</code> <p>Boolean indicating if verification was successful</p> <code>message</code> <code>str</code> <p>Human-readable status message</p> <code>error_details</code> <code>Optional[Dict[str, Any]]</code> <p>Detailed error information if verification failed</p> <code>verified_at</code> <code>datetime</code> <p>Timestamp when verification was performed</p> <p>Methods:</p> Name Description <code>is_success</code> <p>Check if verification was successful</p> <code>get_error_message</code> <p>Get formatted error message</p>"},{"location":"reference/#x402_mock.schemas.BaseVerificationResult.is_success","title":"<code>is_success() -&gt; bool</code>","text":"<p>Check if verification was successful.</p> <p>Convenience method to check if the verification passed.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if verification was successful, False otherwise.</p> Example <p>result = await adapter.verify_signature(permit, payment) if result.is_success():     # Proceed with transaction else:     # Handle verification failure</p>"},{"location":"reference/#x402_mock.schemas.BaseVerificationResult.get_error_message","title":"<code>get_error_message() -&gt; Optional[str]</code>","text":"<p>Get formatted error message from verification result.</p> <p>Returns a human-readable error message explaining why verification failed. Returns None if verification was successful.</p> <p>Returns:</p> Type Description <code>Optional[str]</code> <p>Optional[str]: Error message if verification failed, None if successful.</p> Example <p>if not result.is_success():     error_msg = result.get_error_message()     print(f\"Verification failed: {error_msg}\")</p>"},{"location":"reference/#x402_mock.schemas.TransactionStatus","title":"<code>TransactionStatus</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Enumeration of possible transaction execution statuses.</p> <p>Attributes:</p> Name Type Description <code>SUCCESS</code> <p>Transaction executed successfully on-chain</p> <code>FAILED</code> <p>Transaction reverted or failed on-chain</p> <code>PENDING</code> <p>Transaction is pending confirmation</p> <code>INSUFFICIENT_GAS</code> <p>Transaction failed due to insufficient gas</p> <code>TIMEOUT</code> <p>Transaction confirmation timed out</p> <code>NETWORK_ERROR</code> <p>Network error during transaction submission</p> <code>INVALID_TRANSACTION</code> <p>Transaction is malformed or invalid</p> <code>UNKNOWN_ERROR</code> <p>Unexpected error during transaction execution</p>"},{"location":"reference/#x402_mock.schemas.BaseTransactionConfirmation","title":"<code>BaseTransactionConfirmation</code>","text":"<p>               Bases: <code>CanonicalModel</code>, <code>ABC</code></p> <p>Abstract base class for blockchain transaction confirmation/receipt data.</p> <p>This class captures the result of executing a transaction on-chain, including execution status, timing, and confirmation information.</p> <p>Attributes:</p> Name Type Description <code>confirmation_type</code> <code>str</code> <p>Type of confirmation (e.g., \"evm\", \"svm\")</p> <code>status</code> <code>TransactionStatus</code> <p>Transaction execution status (TransactionStatus enum)</p> <code>execution_time</code> <code>Optional[float]</code> <p>Time taken to confirm transaction (in seconds)</p> <code>confirmations</code> <code>int</code> <p>Number of block confirmations</p> <code>error_message</code> <code>Optional[str]</code> <p>Error message if transaction failed</p> <code>logs</code> <code>Optional[List[Dict[str, Any]]]</code> <p>Optional transaction logs/events</p> <code>created_at</code> <code>datetime</code> <p>Timestamp when confirmation was recorded</p> <p>Methods:</p> Name Description <code>is_success</code> <p>Check if transaction executed successfully</p> <code>get_confirmation_status</code> <p>Get human-readable confirmation status</p>"},{"location":"reference/#x402_mock.schemas.BaseTransactionConfirmation.is_success","title":"<code>is_success() -&gt; bool</code>","text":"<p>Check if transaction executed successfully on-chain.</p> <p>Returns True if the transaction was executed without errors and achieved the intended state change on the blockchain.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if transaction succeeded, False if failed or pending.</p> Example <p>confirmation = await adapter.send_transaction(permit) if confirmation.is_success():     print(f\"Transaction confirmed: {confirmation.tx_hash}\") else:     print(f\"Transaction failed: {confirmation.error_message}\")</p>"},{"location":"reference/#x402_mock.schemas.BaseTransactionConfirmation.get_confirmation_status","title":"<code>get_confirmation_status() -&gt; str</code>","text":"<p>Get human-readable confirmation status message.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Human-readable status message describing transaction state.</p> Example <p>status_msg = confirmation.get_confirmation_status()</p>"},{"location":"reference/#x402_mock.schemas.BaseTransactionConfirmation.get_confirmation_status--may-return-transaction-confirmed-with-10-confirmations","title":"May return: \"Transaction confirmed with 10 confirmations\"","text":""},{"location":"reference/#x402_mock.schemas.ClientRequestHeader","title":"<code>ClientRequestHeader</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>HTTP request headers sent by client.</p> <p>Attributes:</p> Name Type Description <code>content_type</code> <code>str</code> <p>MIME type of request body (default: application/json).</p> <code>authorization</code> <code>Optional[str]</code> <p>Optional bearer token for authenticated requests.</p>"},{"location":"reference/#x402_mock.schemas.ServerPaymentScheme","title":"<code>ServerPaymentScheme</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Payment scheme configuration for client payment authorization.</p> <p>Describes the specific payment requirements and supported payment methods that the client must fulfill to access the protected resource.</p> <p>Attributes:</p> Name Type Description <code>payment_components</code> <code>List[PaymentComponentTypes]</code> <p>List of supported payment options/requirements.</p> <code>protocol_version</code> <code>str</code> <p>Version of the payment protocol being used.</p>"},{"location":"reference/#x402_mock.schemas.Server402ResponsePayload","title":"<code>Server402ResponsePayload</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Server response payload for 402 Payment Required status.</p> <p>This is returned by the server when client attempts to access a protected resource without valid authorization. It instructs the client where to submit payment and what payment methods are accepted.</p> <p>Attributes:</p> Name Type Description <code>access_token_endpoint</code> <code>str</code> <p>URL endpoint for POST request to obtain access token.</p> <code>payment_scheme</code> <code>ServerPaymentScheme</code> <p>Payment requirements and accepted payment methods.</p> <code>payment_instruction</code> <code>Optional[str]</code> <p>Optional instruction explaining payment process and endpoint usage.</p>"},{"location":"reference/#x402_mock.schemas.ClientTokenRequest","title":"<code>ClientTokenRequest</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Client request to exchange permit for access token.</p> <p>The client sends this request to the server's access token endpoint after generating a valid permit that authorizes the payment. The server validates the permit and returns an access token if the permit is valid.</p> <p>This request should be sent as POST with JSON body.</p> <p>Attributes:</p> Name Type Description <code>version</code> <code>ProtocalVersion</code> <p>Protocol version of the permit.</p> <code>permit</code> <code>PermitTypes</code> <p>Signed permit authorizing the payment.</p>"},{"location":"reference/#x402_mock.schemas.ServerTokenResponse","title":"<code>ServerTokenResponse</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Server response containing access token and metadata.</p> <p>Returned when server successfully verifies and accepts a client's permit. The access token is used by client to access the protected resource.</p> <p>Attributes:</p> Name Type Description <code>access_token</code> <code>str</code> <p>Bearer token for authenticating subsequent requests.</p> <code>token_type</code> <code>str</code> <p>Type of token (typically \"Bearer\").</p> <code>expires_in</code> <code>Optional[int]</code> <p>Token lifetime in seconds. None means token never expires.</p> <code>metadata</code> <code>Dict[str, Any]</code> <p>Additional metadata about the token or authorization.</p>"},{"location":"reference/#engine","title":"Engine","text":"<p>Event-Driven Execution Engine</p> <p>The Engine module implements a sophisticated event-driven architecture for orchestrating payment protocol workflows. It provides a typed event system with an event bus that allows subscribers to hook into the payment lifecycle, monitor execution flow, capture errors, and customize behavior at critical execution points.</p> <p>Key Features: - Typed Event System: Strongly-typed events representing each stage of payment processing - Event Bus: Publish-subscribe pattern for decoupled event handling - Hook Subscription: Use <code>add_hook()</code> to subscribe handlers to specific event types - Event Chain Execution: Sequential event processing with state transitions - Comprehensive Events: Request initialization, token exchange, verification, settlement, errors - Dependency Injection: Clean separation of business logic from infrastructure dependencies - Exception Hierarchy: Rich exception types for granular error handling - Async-Native: Built for asynchronous execution with asyncio support</p> <p>Key Event Types: - <code>RequestInitEvent</code>: Initial request with optional authorization token - <code>RequestTokenEvent</code>: Payment permit submission for token exchange - <code>Http402PaymentEvent</code>: Payment required response with payment schemes - <code>VerifySuccessEvent</code> / <code>VerifyFailedEvent</code>: Signature verification results - <code>SettleSuccessEvent</code> / <code>SettleFailedEvent</code>: On-chain settlement outcomes - <code>TokenIssuedEvent</code>: Successful access token generation - <code>AuthorizationSuccessEvent</code>: Successful request authorization</p> <p>Main Components: - <code>EventBus</code>: Central event dispatcher with subscriber management - <code>EventChain</code>: Orchestrates event sequence execution - <code>Dependencies</code>: Immutable container for shared infrastructure - Typed events: All events inherit from <code>BaseEvent</code> - Custom exceptions: Detailed error types for different failure scenarios</p> <p>Usage Pattern: Developers can subscribe custom handlers to events using <code>event_bus.subscribe(EventType, handler)</code> to intercept events, log transactions, trigger webhooks, or implement custom business logic at any point in the payment flow.</p>"},{"location":"reference/#x402_mock.engine","title":"<code>x402_mock.engine</code>","text":""},{"location":"reference/#x402_mock.engine.BaseEvent","title":"<code>BaseEvent</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Base class for all events in the system.</p>"},{"location":"reference/#x402_mock.engine.BaseEvent.__repr__","title":"<code>__repr__() -&gt; str</code>  <code>abstractmethod</code>","text":"<p>String representation of the event.</p>"},{"location":"reference/#x402_mock.engine.RequestInitEvent","title":"<code>RequestInitEvent</code>","text":"<p>               Bases: <code>BaseModel</code>, <code>BaseEvent</code></p> <p>External trigger: Initialize request with token.</p>"},{"location":"reference/#x402_mock.engine.RequestTokenEvent","title":"<code>RequestTokenEvent</code>","text":"<p>               Bases: <code>BaseModel</code>, <code>BaseEvent</code></p> <p>External trigger: Request access token with payment permit.</p>"},{"location":"reference/#x402_mock.engine.AuthorizationSuccessEvent","title":"<code>AuthorizationSuccessEvent</code>","text":"<p>               Bases: <code>BaseModel</code>, <code>BaseEvent</code></p> <p>Result: Authorization succeeded with verified payload.</p>"},{"location":"reference/#x402_mock.engine.Http402PaymentEvent","title":"<code>Http402PaymentEvent</code>","text":"<p>               Bases: <code>BaseModel</code>, <code>BaseEvent</code></p> <p>Result: Payment required - 402 response payload.</p>"},{"location":"reference/#x402_mock.engine.VerifySuccessEvent","title":"<code>VerifySuccessEvent</code>","text":"<p>               Bases: <code>BaseModel</code>, <code>BaseEvent</code></p> <p>Result: Payment verification succeeded.</p>"},{"location":"reference/#x402_mock.engine.VerifyFailedEvent","title":"<code>VerifyFailedEvent</code>","text":"<p>               Bases: <code>BaseModel</code>, <code>BaseEvent</code></p> <p>Result: Payment verification failed.</p>"},{"location":"reference/#x402_mock.engine.SettleFailedEvent","title":"<code>SettleFailedEvent</code>","text":"<p>               Bases: <code>BaseModel</code>, <code>BaseEvent</code></p> <p>Result: Settlement failed.</p>"},{"location":"reference/#x402_mock.engine.SettleSuccessEvent","title":"<code>SettleSuccessEvent</code>","text":"<p>               Bases: <code>BaseModel</code>, <code>BaseEvent</code></p> <p>Result: Settlement succeeded.</p>"},{"location":"reference/#x402_mock.engine.Dependencies","title":"<code>Dependencies</code>  <code>dataclass</code>","text":"<p>Container for infrastructure dependencies (read-only).</p>"},{"location":"reference/#x402_mock.engine.EventBus","title":"<code>EventBus</code>","text":"<p>Event dispatcher for publishing and subscribing to events.</p>"},{"location":"reference/#x402_mock.engine.EventBus.__init__","title":"<code>__init__() -&gt; None</code>","text":"<p>Initialize with empty subscribers and hooks.</p>"},{"location":"reference/#x402_mock.engine.EventBus.subscribe","title":"<code>subscribe(event_class: type[BaseEvent], handler: EventHandlerFunc) -&gt; None</code>","text":"<p>Register an async handler for the given event class. Multiple handlers can be subscribed to the same event type and run in parallel.</p> <p>Parameters:</p> Name Type Description Default <code>event_class</code> <code>type[BaseEvent]</code> <p>The event class to subscribe to.</p> required <code>handler</code> <code>EventHandlerFunc</code> <p>The async handler function to call when the event is published.</p> required <p>Raises:</p> Type Description <code>TypeError</code> <p>If handler is not a coroutine function.</p>"},{"location":"reference/#x402_mock.engine.EventBus.hook","title":"<code>hook(event_class: type[BaseEvent], hook_func: EventHookFunc) -&gt; None</code>","text":"<p>Register a hook for the given event class. Hooks are executed before subscribers when the event is dispatched.</p> <p>Parameters:</p> Name Type Description Default <code>event_class</code> <code>type[BaseEvent]</code> <p>The event class to hook into.</p> required <code>hook_func</code> <code>EventHookFunc</code> <p>The hook function to call when the event is published.</p> required"},{"location":"reference/#x402_mock.engine.EventBus.dispatch","title":"<code>dispatch(event: BaseEvent, deps: Dependencies) -&gt; AsyncGenerator[Optional[BaseEvent], None]</code>  <code>async</code>","text":"<p>Dispatch an event to all registered hooks and subscribers. Hooks run first (synchronously in order), then all subscribers run in parallel.</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>BaseEvent</code> <p>The event to dispatch.</p> required <code>deps</code> <code>Dependencies</code> <p>Dependencies container with injected services.</p> required <p>Yields:</p> Type Description <code>AsyncGenerator[Optional[BaseEvent], None]</code> <p>Results from all subscribers as they complete. Yields nothing if no subscribers are registered.</p>"},{"location":"reference/#x402_mock.engine.TokenIssuedEvent","title":"<code>TokenIssuedEvent</code>","text":"<p>               Bases: <code>BaseModel</code>, <code>BaseEvent</code></p> <p>Result: Access token issued after successful verification.</p>"},{"location":"reference/#x402_mock.engine.BreakEvent","title":"<code>BreakEvent</code>","text":"<p>               Bases: <code>BaseModel</code>, <code>BaseEvent</code></p> <p>Internal event to break the event chain.</p>"},{"location":"reference/#x402_mock.engine.EventChain","title":"<code>EventChain</code>","text":"<p>Executes event-driven workflows by chaining event handler results.</p> <p>Supports early return mechanism: when an event matching early_return_on is encountered, execute() returns that event immediately while remaining processing continues in background.</p>"},{"location":"reference/#x402_mock.engine.EventChain.__init__","title":"<code>__init__(event_bus: EventBus, deps: Dependencies) -&gt; None</code>","text":"<p>Initialize event chain executor.</p> <p>Parameters:</p> Name Type Description Default <code>event_bus</code> <code>EventBus</code> <p>The event bus to dispatch events through.</p> required <code>deps</code> <code>Dependencies</code> <p>Dependencies container to pass to handlers.</p> required"},{"location":"reference/#x402_mock.engine.EventChain.execute","title":"<code>execute(initial_event: BaseEvent) -&gt; AsyncGenerator[BaseEvent, None]</code>  <code>async</code>","text":"<p>Execute event chain starting from initial event.</p> <p>Returns:</p> Type Description <code>AsyncGenerator[BaseEvent, None]</code> <p>Yields events encountered during chain execution.</p> Note <p>When early return is triggered, subsequent events continue processing  asynchronously in background without blocking the return.</p>"},{"location":"reference/#x402_mock.engine.BaseException","title":"<code>BaseException</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Root exception class for all project-specific exceptions.</p> <p>All custom exceptions should inherit from this class to enable unified exception handling and centralized error processing.</p>"},{"location":"reference/#x402_mock.engine.AuthenticationError","title":"<code>AuthenticationError</code>","text":"<p>               Bases: <code>BaseException</code></p> <p>Raised when authentication fails or credentials are invalid.</p> <p>This includes scenarios such as: - Invalid or expired access tokens - Missing authentication headers - Authentication signature verification failure</p>"},{"location":"reference/#x402_mock.engine.PaymentMethodError","title":"<code>PaymentMethodError</code>","text":"<p>               Bases: <code>BaseException</code></p> <p>Raised when a payment method is invalid or unsupported.</p> <p>This includes scenarios such as: - Unsupported payment type (on-chain vs off-chain mismatch) - Missing required payment method configuration - Payment method not registered on server</p>"},{"location":"reference/#x402_mock.engine.PaymentSignatureError","title":"<code>PaymentSignatureError</code>","text":"<p>               Bases: <code>BaseException</code></p> <p>Raised when payment signature generation or processing fails.</p> <p>This includes scenarios such as: - Signature format validation failure - Private key access issues - Signature encoding errors</p>"},{"location":"reference/#x402_mock.engine.TokenError","title":"<code>TokenError</code>","text":"<p>               Bases: <code>BaseException</code></p> <p>Base exception for token-related errors.</p> <p>Parent class for all token validation and management errors.</p>"},{"location":"reference/#x402_mock.engine.TokenExpiredError","title":"<code>TokenExpiredError</code>","text":"<p>               Bases: <code>TokenError</code></p> <p>Raised when a token has expired and is no longer valid.</p> <p>Attributes:</p> Name Type Description <code>expiration_time</code> <p>When the token expired</p>"},{"location":"reference/#x402_mock.engine.InvalidTokenError","title":"<code>InvalidTokenError</code>","text":"<p>               Bases: <code>TokenError</code></p> <p>Raised when a token is invalid or malformed.</p> <p>This includes scenarios such as: - Corrupted token data - Invalid token signature - Unsupported token version</p>"},{"location":"reference/#x402_mock.engine.TokenNotFoundError","title":"<code>TokenNotFoundError</code>","text":"<p>               Bases: <code>TokenError</code></p> <p>Raised when a requested token cannot be found.</p> <p>Typically occurs in token lookup or retrieval operations.</p>"},{"location":"reference/#x402_mock.engine.PaymentVerificationError","title":"<code>PaymentVerificationError</code>","text":"<p>               Bases: <code>BaseException</code></p> <p>Base exception for payment verification failures.</p> <p>Parent class for all errors that occur during payment validation.</p>"},{"location":"reference/#x402_mock.engine.SignatureVerificationError","title":"<code>SignatureVerificationError</code>","text":"<p>               Bases: <code>PaymentVerificationError</code></p> <p>Raised when permit signature verification fails.</p> <p>This includes scenarios such as: - Invalid ECDSA signature - Signature from wrong address - Tampered signature data - Signer address mismatch</p> <p>Attributes:</p> Name Type Description <code>permit_type</code> <p>Type of permit being verified</p> <code>signer</code> <p>Expected signer address</p> <code>recovered</code> <p>Actually recovered address from signature</p>"},{"location":"reference/#x402_mock.engine.PermitExpiredError","title":"<code>PermitExpiredError</code>","text":"<p>               Bases: <code>PaymentVerificationError</code></p> <p>Raised when a permit has expired and can no longer be executed.</p> <p>The permit deadline has passed on the blockchain.</p> <p>Attributes:</p> Name Type Description <code>deadline</code> <p>The expired permit deadline</p> <code>current_time</code> <p>Current block timestamp</p>"},{"location":"reference/#x402_mock.engine.PermitNonceError","title":"<code>PermitNonceError</code>","text":"<p>               Bases: <code>PaymentVerificationError</code></p> <p>Raised when permit nonce is invalid or already used.</p> <p>This protects against replay attacks by ensuring each permit has a unique nonce that increments with each use.</p> <p>Attributes:</p> Name Type Description <code>expected_nonce</code> <p>Nonce expected on-chain</p> <code>provided_nonce</code> <p>Nonce in the permit</p>"},{"location":"reference/#x402_mock.engine.InsufficientFundsError","title":"<code>InsufficientFundsError</code>","text":"<p>               Bases: <code>PaymentVerificationError</code></p> <p>Raised when account balance is insufficient for the payment.</p> <p>This includes scenarios such as: - Token balance less than permit amount - Insufficient gas for transaction execution</p> <p>Attributes:</p> Name Type Description <code>required</code> <p>Amount required</p> <code>available</code> <p>Amount available</p>"},{"location":"reference/#x402_mock.engine.ConfigurationError","title":"<code>ConfigurationError</code>","text":"<p>               Bases: <code>BaseException</code></p> <p>Raised when configuration is missing or invalid.</p> <p>This includes scenarios such as: - Missing required configuration keys - Invalid configuration values - RPC URL unreachable - Unsupported network configuration</p>"},{"location":"reference/#x402_mock.engine.InvalidTransition","title":"<code>InvalidTransition</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Raised when an invalid state transition occurs in event processing.</p> <p>This indicates that the payment state machine received an event that is not valid for the current state.</p> <p>Attributes:</p> Name Type Description <code>current_state</code> <p>Current payment/transaction state</p> <code>event_type</code> <p>Event that triggered the transition</p> <code>message</code> <p>Description of why transition is invalid</p>"},{"location":"reference/#x402_mock.engine.BlockchainInteractionError","title":"<code>BlockchainInteractionError</code>","text":"<p>               Bases: <code>BaseException</code></p> <p>Raised when blockchain interaction (RPC call) fails.</p> <p>This includes scenarios such as: - RPC call timeout - Network connectivity issues - Invalid contract address - Contract call revert</p> <p>Attributes:</p> Name Type Description <code>rpc_method</code> <p>RPC method that was called (e.g., 'eth_call')</p> <code>reason</code> <p>Error reason from blockchain node</p>"},{"location":"reference/#x402_mock.engine.TransactionExecutionError","title":"<code>TransactionExecutionError</code>","text":"<p>               Bases: <code>BlockchainInteractionError</code></p> <p>Raised when blockchain transaction execution fails.</p> <p>This includes scenarios such as: - Transaction reverted on-chain - Out of gas - Invalid transaction parameters - Nonce conflicts</p> <p>Attributes:</p> Name Type Description <code>tx_hash</code> <p>Transaction hash if available</p> <code>revert_reason</code> <p>Reason transaction was reverted</p>"}]}